/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import org.eclipse.jgit.api.CheckoutCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.DeleteBranchCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PullCommand;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.CheckoutConflictException;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.InvalidConfigurationException;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.RefSpec;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.ims.util.ItemAssembler;
import org.opentestsystem.ap.ims.util.ItemBankTestUtil;
import org.opentestsystem.ap.ims.util.SystemException;
import org.opentestsystem.saaif.item.ItemFactory;
import org.opentestsystem.saaif.item.ItemRelease;

import java.io.File;
import java.nio.file.Files;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.ims.client.GitClient.BRANCH_MASTER;
import static org.opentestsystem.ap.ims.client.GitClient.GIT_CONFIG_USER;
import static org.opentestsystem.ap.ims.client.GitClient.GIT_CONFIG_USER_EMAIL;
import static org.opentestsystem.ap.ims.client.GitClient.GIT_CONFIG_USER_NAME;
import static org.opentestsystem.ap.ims.util.ItemBankTestUtil.ITEM_BANK_USER;
import static org.opentestsystem.ap.ims.util.ItemBankTestUtil.ITEM_ID;
import static org.opentestsystem.saaif.item.ItemConstants.ItemFormat.FORMAT_SHORT_ANSWER;

@RunWith(MockitoJUnitRunner.class)
public class GitClientTest {

    private static final ItemFactory FACTORY = new ItemFactory();

    @Mock
    private Git mockGit;

    @Mock
    private Repository mockRepository;

    @Mock
    private StoredConfig mockConfig;

    @Mock
    private CloneCommand mockCloneCommand;

    @Mock
    private CommitCommand mockCommitCommand;

    @Mock
    private PushCommand mockPushCommand;

    @Mock
    private CheckoutCommand mockCheckoutCommand;

    @Mock
    private DeleteBranchCommand mockDeleteBranchCommand;

    @Mock
    private PullCommand mockPullCommand;

    @Mock
    private RefSpec mockRefSpec;

    private GitClient spyGitClient;

    private GitClient gitClient;

    private ItemAssembler itemAssembler;

    private ItemBankTestUtil itemBankTestUtil;

    @Before
    public void setup() {
        itemAssembler = new ItemAssembler();
        itemAssembler.init();

        itemBankTestUtil = new ItemBankTestUtil();

        gitClient = new GitClient(itemBankTestUtil.getGitlabProperties(), ITEM_BANK_USER, ITEM_ID, itemAssembler);
        gitClient.setGit(mockGit);

        spyGitClient = spy(gitClient);
    }

    @After
    public void teardown() {
        if (itemBankTestUtil != null) {
            itemBankTestUtil.cleanup();
        }
    }

    // ------------------------------------------------------------------------


    @Test
    public void itShouldDeleteScratchPad() {
        doNothing().when(spyGitClient).deleteRemoteBranch(ITEM_BANK_USER.getUsername());
        doNothing().when(spyGitClient).deleteLocalBranch(ITEM_BANK_USER.getUsername());

        spyGitClient.deleteScratchPad();

        verify(spyGitClient, times(1)).deleteRemoteBranch(ITEM_BANK_USER.getUsername());
        verify(spyGitClient, times(1)).deleteLocalBranch(ITEM_BANK_USER.getUsername());
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenDeletingRemoteBranch() throws GitAPIException {
        final InvalidConfigurationException mockException = mock(InvalidConfigurationException.class);

        doReturn(mockRefSpec).when(spyGitClient).newRefSpec();

        when(mockRefSpec.setSource(null)).thenReturn(mockRefSpec);
        when(mockRefSpec.setDestination("refs/heads/" + ITEM_BANK_USER.getUsername())).thenReturn(mockRefSpec);

        when(mockGit.push()).thenReturn(mockPushCommand);
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPushCommand);

        when(mockPushCommand.setRefSpecs(mockRefSpec)).thenReturn(mockPushCommand);
        when(mockPushCommand.setRemote("origin")).thenReturn(mockPushCommand);

        when(mockPushCommand.call()).thenThrow(mockException);

        spyGitClient.deleteRemoteBranch(ITEM_BANK_USER.getUsername());
    }

    @Test
    public void itShouldDeleteRemoteBranch() {
        doReturn(mockRefSpec).when(spyGitClient).newRefSpec();

        when(mockRefSpec.setSource(null)).thenReturn(mockRefSpec);
        when(mockRefSpec.setDestination("refs/heads/" + ITEM_BANK_USER.getUsername())).thenReturn(mockRefSpec);

        when(mockGit.push()).thenReturn(mockPushCommand);
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPushCommand);

        when(mockPushCommand.setRefSpecs(mockRefSpec)).thenReturn(mockPushCommand);
        when(mockPushCommand.setRemote("origin")).thenReturn(mockPushCommand);

        spyGitClient.deleteRemoteBranch(ITEM_BANK_USER.getUsername());

        verify(mockRefSpec, times(1)).setSource(null);
        verify(mockRefSpec, times(1)).setDestination("refs/heads/" + ITEM_BANK_USER.getUsername());
        verify(mockPushCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockPushCommand, times(1)).setRefSpecs(mockRefSpec);
        verify(mockPushCommand, times(1)).setRemote("origin");
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenDeletingLocalBranch() throws GitAPIException {
        final InvalidConfigurationException mockException = mock(InvalidConfigurationException.class);

        when(mockGit.branchDelete()).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setBranchNames(ITEM_BANK_USER.getUsername())).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setForce(true)).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.call()).thenThrow(mockException);

        gitClient.deleteLocalBranch(ITEM_BANK_USER.getUsername());
    }

    @Test
    public void itShouldDeleteLocalBranch() {
        when(mockGit.branchDelete()).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setBranchNames(ITEM_BANK_USER.getUsername())).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setForce(true)).thenReturn(mockDeleteBranchCommand);

        gitClient.deleteLocalBranch(ITEM_BANK_USER.getUsername());

        verify(mockGit, times(1)).branchDelete();
        verify((mockDeleteBranchCommand), times(1)).setBranchNames(ITEM_BANK_USER.getUsername());
        verify((mockDeleteBranchCommand), times(1)).setForce(true);
    }

    @Test
    public void itShouldMergeScratchPad() {
        doNothing().when(spyGitClient).pullRemoteBranchIntoCurrentLocal(ITEM_BANK_USER.getUsername());

        spyGitClient.mergeScratchPad();

        verify(spyGitClient, times(1)).pullRemoteBranchIntoCurrentLocal(ITEM_BANK_USER.getUsername());
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenPullingRemoteBranchIntoCurrentLocal() throws GitAPIException {
        final String branchName = "test-branch";
        final InvalidConfigurationException mockException = mock(InvalidConfigurationException.class);

        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        when(mockPullCommand.setRemoteBranchName(branchName)).thenReturn(mockPullCommand);
        when(mockPullCommand.call()).thenThrow(mockException);

        gitClient.pullRemoteBranchIntoCurrentLocal(branchName);
    }

    @Test
    public void itShouldPullRemoteBranchIntoCurrentLocal() {
        final String branchName = "test-branch";

        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        when(mockPullCommand.setRemoteBranchName(branchName)).thenReturn(mockPullCommand);

        gitClient.pullRemoteBranchIntoCurrentLocal(branchName);
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenPullingLatest() throws GitAPIException {
        final InvalidConfigurationException mockException = mock(InvalidConfigurationException.class);

        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        when(mockPullCommand.call()).thenThrow(mockException);

        gitClient.pullLatest();
    }

    @Test
    public void itShouldPullLatest() {
        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        gitClient.pullLatest();
    }

    @Test
    public void itShouldCheckoutMasterBranch() {
        doNothing().when(spyGitClient).checkoutBranch(BRANCH_MASTER);

        spyGitClient.checkoutMasterBranch();

        verify(spyGitClient, times(1)).checkoutBranch(BRANCH_MASTER);
    }

    @Test
    public void itShouldCheckoutScratchPadBranch() {
        doNothing().when(spyGitClient).checkoutBranch(ITEM_BANK_USER.getUsername());

        spyGitClient.checkoutScratchPad();

        verify(spyGitClient, times(1)).checkoutBranch(ITEM_BANK_USER.getUsername());
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenCheckingOutBranchByName() throws GitAPIException {
        final CheckoutConflictException mockException = mock(CheckoutConflictException.class);

        when(mockGit.checkout()).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.setName(ITEM_ID)).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.call()).thenThrow(mockException);

        gitClient.checkoutBranch(ITEM_ID);
    }

    @Test
    public void itShouldCheckoutBranchByName() throws GitAPIException {
        when(mockGit.checkout()).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.setName(ITEM_ID)).thenReturn(mockCheckoutCommand);

        gitClient.checkoutBranch(ITEM_ID);

        verify(mockGit, times(1)).checkout();
        verify(mockCheckoutCommand, times(1)).setName(ITEM_ID);
        verify(mockCheckoutCommand, times(1)).call();
    }

    @Test
    public void itShouldReadItemFile() {
        final ItemRelease expected = FACTORY.newAssessmentItem(ITEM_ID, FORMAT_SHORT_ANSWER);
        gitClient.writeItemFile(expected);

        final ItemRelease actual = spyGitClient.readItemFile();

        assertThat(actual).isNotNull();
        assertThat(actual.getItem().getId()).isEqualTo(ITEM_ID);
    }

    @Test
    public void itShouldCloneRemoteRepository() throws GitAPIException {
        setMocksForCloneRepository();

        spyGitClient.cloneRemoteRepository();

        assertCloneRepository();
    }

    @Test
    public void itShouldCloneRepository() throws GitAPIException {
        setMocksForCloneRepository();

        final Git git = spyGitClient.cloneRepository();

        assertThat(git).isEqualTo(mockGit);
        assertCloneRepository();
    }

    private void setMocksForCloneRepository() throws GitAPIException {
        when(mockCloneCommand.setURI(anyString())).thenReturn(mockCloneCommand);

        when(mockCloneCommand.setDirectory(any(File.class))).thenReturn(mockCloneCommand);

        when(mockCloneCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockCloneCommand);

        when(mockCloneCommand.call()).thenReturn(mockGit);

        when(spyGitClient.cloneCommand()).thenReturn(mockCloneCommand);

        doNothing().when(spyGitClient).setUserInfo();
    }

    private void assertCloneRepository() throws GitAPIException {
        verify(mockCloneCommand, times(1)).setURI(anyString());
        verify(mockCloneCommand, times(1)).setDirectory(any(File.class));
        verify(mockCloneCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockCloneCommand, times(1)).call();
    }

    @Test
    public void itShouldPush() throws GitAPIException {
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class))).thenReturn
            (mockPushCommand);
        when(mockGit.push()).thenReturn(mockPushCommand);

        gitClient.push();

        verify(mockPushCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockPushCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessagePresent() throws GitAPIException {
        final String message = "Test Commit Message";

        when(mockCommitCommand.setMessage(message)).thenReturn(mockCommitCommand);
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        gitClient.commit(message);

        verify(mockCommitCommand, times(1)).setMessage(message);
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessageNotPresent() throws GitAPIException {
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        gitClient.commit(null);

        verify(mockCommitCommand, never()).setMessage(anyString());
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldGenerateRepositoryURI() {
        final String expected = String.format("%s/%s/%s.git",
            itemBankTestUtil.getGitlabHost(),
            itemBankTestUtil.getGitlabGroup(),
            itemBankTestUtil.getGitLabProject());

        final String actual = gitClient.generateRepositoryURI(itemBankTestUtil.getGitLabProject());

        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void itShouldDeleteDirectory() {
        // setup creates the directories
        assertThat(Files.exists(itemBankTestUtil.getLocalRepoDir())).isEqualTo(true);
        assertThat(Files.isDirectory(itemBankTestUtil.getLocalRepoDir())).isEqualTo(true);

        gitClient.deleteDirectory(itemBankTestUtil.getLocalRepoDir());

        assertThat(Files.exists(itemBankTestUtil.getLocalRepoDir())).isEqualTo(false);
    }

    @Test
    public void itShouldsetUserInfo() {
        final String username = "johndoe@fake.com";
        final String fullname = "John Doe";


        when(mockRepository.getConfig()).thenReturn(mockConfig);
        when(mockGit.getRepository()).thenReturn(mockRepository);

        gitClient.setUserInfo();

        verify(mockConfig, times(1)).setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, ITEM_BANK_USER
            .getFullname());
        verify(mockConfig, times(1)).setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, ITEM_BANK_USER
            .getUsername());
    }


}
