/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CheckoutCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.CreateBranchCommand;
import org.eclipse.jgit.api.DeleteBranchCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PullCommand;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.InvalidConfigurationException;
import org.eclipse.jgit.errors.RepositoryNotFoundException;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.RefSpec;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.ims.util.IMSTestUtil;
import org.opentestsystem.ap.ims.util.SaaifAssembler;
import org.opentestsystem.ap.ims.util.SystemException;
import org.opentestsystem.saaif.item.ItemRelease;
import org.opentestsystem.saaif.item.SaaifItemFactory;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.ims.client.GitClient.BRANCH_MASTER;
import static org.opentestsystem.ap.ims.client.GitClient.GIT_CONFIG_USER;
import static org.opentestsystem.ap.ims.client.GitClient.GIT_CONFIG_USER_EMAIL;
import static org.opentestsystem.ap.ims.client.GitClient.GIT_CONFIG_USER_NAME;
import static org.opentestsystem.ap.ims.client.GitClient.SCRATCH_PAD;
import static org.opentestsystem.ap.ims.util.IMSTestUtil.ITEM_BANK_USER;
import static org.opentestsystem.ap.ims.util.IMSTestUtil.ITEM_ID;
import static org.opentestsystem.saaif.item.SaaifItemConstants.ItemFormat.FORMAT_SA;

@RunWith(MockitoJUnitRunner.class)
public class GitClientTest {

    private static final SaaifItemFactory FACTORY = new SaaifItemFactory();

    private static final String BRANCH_NAME = "test-branch";

    @Mock
    private InvalidConfigurationException mockException;

    @Mock
    private Git mockGit;

    @Mock
    private Repository mockRepository;

    @Mock
    private StoredConfig mockConfig;

    @Mock
    private CloneCommand mockCloneCommand;

    @Mock
    private CommitCommand mockCommitCommand;

    @Mock
    private PushCommand mockPushCommand;

    @Mock
    private CheckoutCommand mockCheckoutCommand;

    @Mock
    private DeleteBranchCommand mockDeleteBranchCommand;

    @Mock
    private PullCommand mockPullCommand;

    @Mock
    private RefSpec mockRefSpec;

    @Mock
    private CreateBranchCommand mockCreateBranchCommand;

    @Mock
    private AddCommand mockAddCommand;

    @Mock
    private Ref mockRef;

    private GitClient spyGitClient;

    private GitClient gitClient;

    private SaaifAssembler saaifAssembler;

    private IMSTestUtil testUtil;

    private String scratchPadName;

    @Before
    public void setup() {
        scratchPadName = SCRATCH_PAD + "_" + ITEM_BANK_USER.getUsername();

        testUtil = new IMSTestUtil();

        saaifAssembler = new SaaifAssembler();
        saaifAssembler.init();

        gitClient = new GitClient(testUtil.getGitlabProperties(), ITEM_BANK_USER, ITEM_ID, saaifAssembler);
        gitClient.setGit(mockGit);

        spyGitClient = spy(gitClient);

        doReturn(scratchPadName).when(spyGitClient).generateScratchPadName();
    }

    @After
    public void teardown() {
        if (testUtil != null) {
            testUtil.cleanup();
        }
    }

    // ------------------------------------------------------------------------


    @Test(expected = SystemException.class)
    public void itShouldThrowWhenOpenOrClone() throws IOException {
        final IOException exception = mock(IOException.class);

        doThrow(exception).when(spyGitClient).openRepository();

        spyGitClient.openOrClone();
    }

    @Test
    public void itShouldCloneRemoteWhenRepositoryNotFoundDuringOpenOrClone() throws IOException {
        final RepositoryNotFoundException exception = mock(RepositoryNotFoundException.class);

        doThrow(exception).when(spyGitClient).openRepository();
        doReturn(mockGit).when(spyGitClient).cloneRepository();
        doNothing().when(spyGitClient).setUserInfo();

        spyGitClient.openOrClone();

        verify(spyGitClient, times(1)).openOrClone();
        verify(spyGitClient, times(1)).cloneRepository();
        verify(spyGitClient, times(1)).setUserInfo();
    }

    @Test
    public void itShouldOpenOrClone() throws IOException {
        doReturn(mockGit).when(spyGitClient).openRepository();
        doNothing().when(spyGitClient).setUserInfo();

        spyGitClient.openOrClone();

        verify(spyGitClient, times(1)).openOrClone();
        verify(mockGit, times(1)).pull();
        verify(spyGitClient, times(1)).setUserInfo();
    }

    @Test
    public void itShouldCreateRefSpec() {
        final RefSpec refSpec = gitClient.newRefSpec();
        assertThat(refSpec).isNotNull();
    }

    @Test
    public void itShouldStageItemFile() {
        final String fileName = "fileName";

        doReturn(fileName).when(spyGitClient).generateItemFileName();
        doNothing().when(spyGitClient).stageFiles(fileName);

        spyGitClient.stageItemFile();

        verify(spyGitClient, times(1)).stageFiles(fileName);
    }

    @Test(expected = SystemException.class)
    public void itShouldThrownWhenStagingFiles() throws GitAPIException {
        final String fileName = "fileName";

        when(mockGit.add()).thenReturn(mockAddCommand);
        when(mockAddCommand.addFilepattern(fileName)).thenReturn(mockAddCommand);
        when(mockAddCommand.call()).thenThrow(mockException);

        gitClient.stageFiles(fileName);
    }

    @Test
    public void itShouldStageFiles() throws GitAPIException {
        final String fileName = "fileName";

        when(mockGit.add()).thenReturn(mockAddCommand);
        when(mockAddCommand.addFilepattern(fileName)).thenReturn(mockAddCommand);

        gitClient.stageFiles(fileName);

        verify(mockGit, times(1)).add();
        verify(mockAddCommand, times(1)).addFilepattern(fileName);
        verify(mockAddCommand, times(1)).call();
    }

    @Test
    public void itShouldGenerateScratchPadName() {
        final String scratchPadName = gitClient.generateScratchPadName();
        assertThat(scratchPadName).isEqualTo(SCRATCH_PAD + "_" + ITEM_BANK_USER.getUsername());
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowWhenCreatingScratchPadBranch() throws GitAPIException {
        final String scratchPadName = "scratchPad";

        doReturn(scratchPadName).when(spyGitClient).generateScratchPadName();
        when(mockGit.branchCreate()).thenReturn(mockCreateBranchCommand);
        when(mockCreateBranchCommand.setName(scratchPadName)).thenReturn(mockCreateBranchCommand);
        when(mockCreateBranchCommand.call()).thenThrow(mockException);

        spyGitClient.createScratchPad();
    }

    @Test
    public void itShouldCreateScratchPadBranch() throws GitAPIException {
        final String scratchPadName = "scratchPad";
        doReturn(scratchPadName).when(spyGitClient).generateScratchPadName();

        when(mockGit.branchCreate()).thenReturn(mockCreateBranchCommand);
        when(mockCreateBranchCommand.setName(scratchPadName)).thenReturn(mockCreateBranchCommand);

        when(mockGit.checkout()).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.setName(scratchPadName)).thenReturn(mockCheckoutCommand);

        spyGitClient.createScratchPad();

        verify(spyGitClient, times(1)).generateScratchPadName();

        verify(mockGit, times(1)).branchCreate();
        verify(mockCreateBranchCommand, times(1)).setName(scratchPadName);
        verify(mockCreateBranchCommand, times(1)).call();

        verify(mockGit, times(1)).checkout();
        verify(mockCheckoutCommand, times(1)).setName(scratchPadName);
        verify(mockCheckoutCommand, times(1)).call();
    }

    @Test
    public void itShouldDeleteRemoteScratchPad() {
        doNothing().when(spyGitClient).deleteRemoteBranch(scratchPadName);

        spyGitClient.deleteRemoteScratchPad();

        verify(spyGitClient, times(1)).deleteRemoteBranch(scratchPadName);
    }

    @Test
    public void itShouldDeleteLocalScratchPad() {
        doNothing().when(spyGitClient).deleteLocalBranch(scratchPadName);

        spyGitClient.deleteLocalScratchPad();

        verify(spyGitClient, times(1)).deleteLocalBranch(scratchPadName);
    }

    @Test
    public void itShouldDeleteScratchPad() {
        doNothing().when(spyGitClient).deleteRemoteBranch(scratchPadName);
        doNothing().when(spyGitClient).deleteLocalBranch(scratchPadName);

        spyGitClient.deleteScratchPad();

        verify(spyGitClient, times(1)).deleteRemoteBranch(scratchPadName);
        verify(spyGitClient, times(1)).deleteLocalBranch(scratchPadName);
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenDeletingRemoteBranch() throws GitAPIException {
        doReturn(mockRefSpec).when(spyGitClient).newRefSpec();

        when(mockRefSpec.setSource(null)).thenReturn(mockRefSpec);
        when(mockRefSpec.setDestination("refs/heads/" + ITEM_BANK_USER.getUsername())).thenReturn(mockRefSpec);

        when(mockGit.push()).thenReturn(mockPushCommand);
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPushCommand);

        when(mockPushCommand.setRefSpecs(mockRefSpec)).thenReturn(mockPushCommand);
        when(mockPushCommand.setRemote("origin")).thenReturn(mockPushCommand);

        when(mockPushCommand.call()).thenThrow(mockException);

        spyGitClient.deleteRemoteBranch(ITEM_BANK_USER.getUsername());
    }

    @Test
    public void itShouldDeleteRemoteBranch() {
        doReturn(mockRefSpec).when(spyGitClient).newRefSpec();

        when(mockRefSpec.setSource(null)).thenReturn(mockRefSpec);
        when(mockRefSpec.setDestination("refs/heads/" + ITEM_BANK_USER.getUsername())).thenReturn(mockRefSpec);

        when(mockGit.push()).thenReturn(mockPushCommand);
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPushCommand);

        when(mockPushCommand.setRefSpecs(mockRefSpec)).thenReturn(mockPushCommand);
        when(mockPushCommand.setRemote("origin")).thenReturn(mockPushCommand);

        spyGitClient.deleteRemoteBranch(ITEM_BANK_USER.getUsername());

        verify(mockRefSpec, times(1)).setSource(null);
        verify(mockRefSpec, times(1)).setDestination("refs/heads/" + ITEM_BANK_USER.getUsername());
        verify(mockPushCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockPushCommand, times(1)).setRefSpecs(mockRefSpec);
        verify(mockPushCommand, times(1)).setRemote("origin");
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenDeletingLocalBranch() throws GitAPIException {
        when(mockGit.branchDelete()).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setBranchNames(ITEM_BANK_USER.getUsername())).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setForce(true)).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.call()).thenThrow(mockException);

        gitClient.deleteLocalBranch(ITEM_BANK_USER.getUsername());
    }

    @Test
    public void itShouldDeleteLocalBranch() {
        when(mockGit.branchDelete()).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setBranchNames(ITEM_BANK_USER.getUsername())).thenReturn(mockDeleteBranchCommand);
        when(mockDeleteBranchCommand.setForce(true)).thenReturn(mockDeleteBranchCommand);

        gitClient.deleteLocalBranch(ITEM_BANK_USER.getUsername());

        verify(mockGit, times(1)).branchDelete();
        verify((mockDeleteBranchCommand), times(1)).setBranchNames(ITEM_BANK_USER.getUsername());
        verify((mockDeleteBranchCommand), times(1)).setForce(true);
    }

    @Test
    public void itShouldMergeScratchPad() throws IOException {
        final String scratchPadName = SCRATCH_PAD + "_" + ITEM_BANK_USER.getUsername();

        doReturn(scratchPadName).when(spyGitClient).generateScratchPadName();

        when(mockGit.getRepository()).thenReturn(mockRepository);
        when(mockRepository.findRef(scratchPadName)).thenReturn(mockRef);
        doNothing().when(spyGitClient).merge(mockRef);

        spyGitClient.mergeScratchPad();

        verify(spyGitClient, times(1)).merge(mockRef);
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenPullingRemoteBranchIntoCurrentLocal() throws GitAPIException {
        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        when(mockPullCommand.setRemoteBranchName(BRANCH_NAME)).thenReturn(mockPullCommand);
        when(mockPullCommand.call()).thenThrow(mockException);

        gitClient.pullRemoteBranchIntoCurrentLocal(BRANCH_NAME);
    }

    @Test
    public void itShouldPullRemoteBranchIntoCurrentLocal() {
        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        when(mockPullCommand.setRemoteBranchName(BRANCH_NAME)).thenReturn(mockPullCommand);

        gitClient.pullRemoteBranchIntoCurrentLocal(BRANCH_NAME);
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenPullingLatest() throws GitAPIException {
        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        when(mockPullCommand.call()).thenThrow(mockException);

        gitClient.pullLatest();
    }

    @Test
    public void itShouldPullLatest() {
        when(mockGit.pull()).thenReturn(mockPullCommand);
        when(mockPullCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockPullCommand);
        gitClient.pullLatest();
    }

    @Test
    public void itShouldCheckoutMasterBranch() {
        doReturn(mockRef).when(spyGitClient).checkoutBranch(BRANCH_MASTER);

        spyGitClient.checkoutMasterBranch();

        verify(spyGitClient, times(1)).checkoutBranch(BRANCH_MASTER);
    }

    @Test
    public void itShouldCheckoutScratchPadBranch() {
        final String scratchPadName = "scratchPad";

        doReturn(scratchPadName).when(spyGitClient).generateScratchPadName();
        doReturn(mockRef).when(spyGitClient).checkoutBranch(scratchPadName);

        spyGitClient.checkoutScratchPad();

        verify(spyGitClient, times(1)).generateScratchPadName();
        verify(spyGitClient, times(1)).checkoutBranch(scratchPadName);
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowSystemExceptionWhenCheckingOutBranchByName() throws GitAPIException {
        when(mockGit.checkout()).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.setName(ITEM_ID)).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.call()).thenThrow(mockException);

        gitClient.checkoutBranch(ITEM_ID);
    }

    @Test
    public void itShouldCheckoutBranchByName() throws GitAPIException {
        when(mockGit.checkout()).thenReturn(mockCheckoutCommand);
        when(mockCheckoutCommand.setName(ITEM_ID)).thenReturn(mockCheckoutCommand);

        gitClient.checkoutBranch(ITEM_ID);

        verify(mockGit, times(1)).checkout();
        verify(mockCheckoutCommand, times(1)).setName(ITEM_ID);
        verify(mockCheckoutCommand, times(1)).call();
    }

    @Test
    public void itShouldReadItemFile() {
        final ItemRelease expected = FACTORY.newAssessmentItem(ITEM_ID, FORMAT_SA);
        gitClient.writeItemFile(expected);

        final ItemRelease actual = spyGitClient.readItemFile();

        assertThat(actual).isNotNull();
        assertThat(actual.getItem().getId()).isEqualTo(ITEM_ID);
    }

    @Test
    public void itShouldCloneRemoteRepository() throws GitAPIException {
        setMocksForCloneRepository();

        spyGitClient.cloneRemoteRepository();

        assertCloneRepository();
    }

    @Test
    public void itShouldCloneRepository() throws GitAPIException {
        setMocksForCloneRepository();

        final Git git = spyGitClient.cloneRepository();

        assertThat(git).isEqualTo(mockGit);
        assertCloneRepository();
    }

    private void setMocksForCloneRepository() throws GitAPIException {
        when(mockCloneCommand.setURI(anyString())).thenReturn(mockCloneCommand);

        when(mockCloneCommand.setDirectory(any(File.class))).thenReturn(mockCloneCommand);

        when(mockCloneCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockCloneCommand);

        when(mockCloneCommand.call()).thenReturn(mockGit);

        when(spyGitClient.cloneCommand()).thenReturn(mockCloneCommand);

        doNothing().when(spyGitClient).setUserInfo();
    }

    private void assertCloneRepository() throws GitAPIException {
        verify(mockCloneCommand, times(1)).setURI(anyString());
        verify(mockCloneCommand, times(1)).setDirectory(any(File.class));
        verify(mockCloneCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockCloneCommand, times(1)).call();
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowWhenPushing() throws GitAPIException {
        when(mockGit.push()).thenReturn(mockPushCommand);
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class))).thenReturn
            (mockPushCommand);
        when(mockPushCommand.call()).thenThrow(mockException);

        gitClient.push();
    }

    @Test
    public void itShouldPush() throws GitAPIException {
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class))).thenReturn
            (mockPushCommand);
        when(mockGit.push()).thenReturn(mockPushCommand);

        gitClient.push();

        verify(mockPushCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockPushCommand, times(1)).call();
    }

    @Test(expected = SystemException.class)
    public void itShouldThrowWhenCommitting() throws GitAPIException {
        final String message = "Test Commit Message";

        when(mockGit.commit()).thenReturn(mockCommitCommand);
        when(mockCommitCommand.setMessage(message)).thenReturn(mockCommitCommand);
        when(mockCommitCommand.call()).thenThrow(mockException);

        gitClient.commit(message);
    }

    @Test
    public void itShouldCommitWhenMessagePresent() throws GitAPIException {
        final String message = "Test Commit Message";

        when(mockCommitCommand.setMessage(message)).thenReturn(mockCommitCommand);
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        gitClient.commit(message);

        verify(mockCommitCommand, times(1)).setMessage(message);
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessageNotPresent() throws GitAPIException {
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        gitClient.commit(null);

        verify(mockCommitCommand, never()).setMessage(anyString());
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldGenerateRepositoryURI() {
        final String expected = String.format("%s/%s/%s.git",
            testUtil.getGitlabHost(),
            testUtil.getGitlabGroup(),
            testUtil.getGitLabProject());

        final String actual = gitClient.generateRepositoryURI(testUtil.getGitLabProject());

        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void itShouldDeleteDirectory() {
        // setup creates the directories
        assertThat(Files.exists(testUtil.getLocalRepoDir())).isEqualTo(true);
        assertThat(Files.isDirectory(testUtil.getLocalRepoDir())).isEqualTo(true);

        gitClient.deleteDirectory(testUtil.getLocalRepoDir());

        assertThat(Files.exists(testUtil.getLocalRepoDir())).isEqualTo(false);
    }

    @Test
    public void itShouldsetUserInfo() {
        final String username = "johndoe@fake.com";
        final String fullname = "John Doe";


        when(mockRepository.getConfig()).thenReturn(mockConfig);
        when(mockGit.getRepository()).thenReturn(mockRepository);

        gitClient.setUserInfo();

        verify(mockConfig, times(1)).setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, ITEM_BANK_USER
            .getFullname());
        verify(mockConfig, times(1)).setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, ITEM_BANK_USER
            .getUsername());
    }
}
