/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.opentestsystem.ap.ims.util.GitTestUtil;

import java.io.File;
import java.nio.file.Files;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.ims.client.GitLabGitClientImpl.README_FILE;

public class GitLabGitClientImplTest {

    @Mock
    private Git mockGit;

    @Mock
    private AddCommand mockAddCommand;

    @Mock
    private CommitCommand mockCommitCommand;

    @Mock
    private PushCommand mockPushCommand;

    private GitTestUtil gitTestUtil;

    private GitLabGitClientImpl client;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        gitTestUtil = new GitTestUtil();
        client = new GitLabGitClientImpl(gitTestUtil.getGitlabProperties());
    }

    @After
    public void teardown() {
        if (gitTestUtil != null) {
            gitTestUtil.cleanup();
        }
    }

    // ------------------------------------------------------------------------

    @Test
    public void itShouldCloneRepository() {
        client.cloneRepository(gitTestUtil.getGitLabProject());
    }

    @Test
    public void itShouldPush() throws GitAPIException {
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class))).thenReturn
            (mockPushCommand);
        when(mockGit.push()).thenReturn(mockPushCommand);

        client.push(mockGit);

        verify(mockPushCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockPushCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessagePresent() throws GitAPIException {
        final String message = "Test Commit Message";

        when(mockCommitCommand.setMessage(message)).thenReturn(mockCommitCommand);
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        client.commit(mockGit, Optional.of(message));

        verify(mockCommitCommand, times(1)).setMessage(message);
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessageNotPresent() throws GitAPIException {
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        client.commit(mockGit, Optional.empty());

        verify(mockCommitCommand, never()).setMessage(anyString());
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldAddReadMe() throws GitAPIException {
        when(mockAddCommand.addFilepattern(README_FILE)).thenReturn(mockAddCommand);
        when(mockGit.add()).thenReturn(mockAddCommand);

        client.addReadMe(mockGit);

        verify(mockAddCommand, times(1)).addFilepattern(README_FILE);
        verify(mockAddCommand, times(1)).call();
    }

    @Test
    public void itShouldWriteReadMeFileToLocalGitRepository() {
        client.writeReadMeToLocalRepo(gitTestUtil.getGitLabProject());
        assertThat(new File(gitTestUtil.getLocalRepoDir().toString() + "/" + README_FILE).isFile())
            .isEqualTo(true);
    }

    @Test
    public void itShouldGenerateRepositoryURI() {
        final String expected = String.format("%s/%s/%s.git",
            gitTestUtil.getGitlabHost(),
            gitTestUtil.getGitlabGroup(),
            gitTestUtil.getGitLabProject());

        final String actual = client.generateRepositoryURI(gitTestUtil.getGitLabProject());

        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void itShouldDeleteDirectory() {
        // setup creates the directories
        assertThat(Files.exists(gitTestUtil.getLocalRepoDir())).isEqualTo(true);
        assertThat(Files.isDirectory(gitTestUtil.getLocalRepoDir())).isEqualTo(true);

        client.deleteDirectory(gitTestUtil.getLocalRepoDir());

        assertThat(Files.exists(gitTestUtil.getLocalRepoDir())).isEqualTo(false);
    }

}
