/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.opentestsystem.ap.ims.config.GitlabProperties;
import org.opentestsystem.ap.ims.util.GitTestUtil;
import org.opentestsystem.ap.ims.util.SecurityUtil;

import java.io.File;
import java.nio.file.Files;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import static org.opentestsystem.ap.ims.client.GitLabGitClientImpl.GIT_CONFIG_USER;
import static org.opentestsystem.ap.ims.client.GitLabGitClientImpl.GIT_CONFIG_USER_EMAIL;
import static org.opentestsystem.ap.ims.client.GitLabGitClientImpl.GIT_CONFIG_USER_NAME;
import static org.opentestsystem.ap.ims.client.GitLabGitClientImpl.README_FILE;

public class GitLabGitClientImplTest {

    @Mock
    private Git mockGit;

    @Mock
    private Repository mockRepository;

    @Mock
    private StoredConfig mockConfig;

    @Mock
    private CloneCommand mockCloneCommand;

    @Mock
    private AddCommand mockAddCommand;

    @Mock
    private CommitCommand mockCommitCommand;

    @Mock
    private PushCommand mockPushCommand;

    @Mock
    private SecurityUtil mockSecurityUtil;

    private GitLabGitClientImpl spyClient;

    private GitLabGitClientImpl client;

    private GitTestUtil gitTestUtil;

    private GitlabProperties gitlabProperties;

    @Before
    public void setup() {
        initMocks(this);

        gitTestUtil = new GitTestUtil();
        gitlabProperties = gitTestUtil.getGitlabProperties();

        client = new GitLabGitClientImpl(gitTestUtil.getGitlabProperties(), mockSecurityUtil);
        spyClient = spy(client);
    }

    @After
    public void teardown() {
        if (gitTestUtil != null) {
            gitTestUtil.cleanup();
        }
    }

    // ------------------------------------------------------------------------

    @Test
    public void itShouldInitializeRemoteRepository() {
        final String project = gitTestUtil.getGitLabProject();

        doAnswer(new Answer<Git>() {
            public Git answer(InvocationOnMock invocation) {
                return mockGit;
            }
        }).when(spyClient).cloneRepository(project);

        doNothing().when(spyClient).setUserInfo(mockGit);
        doNothing().when(spyClient).writeReadMeToLocalRepo(project);
        doNothing().when(spyClient).addReadMe(mockGit);
        doNothing().when(spyClient).commit(mockGit, gitlabProperties.getOptionalInitialCommitMessage());
        doNothing().when(spyClient).push(mockGit);

        spyClient.initializeRemoteRepository(project);

        verify(spyClient, times(1)).cloneRepository(project);
        verify(spyClient, times(1)).setUserInfo(mockGit);
        verify(spyClient, times(1)).writeReadMeToLocalRepo(project);
        verify(spyClient, times(1)).commit(mockGit, gitlabProperties.getOptionalInitialCommitMessage());
        verify(spyClient, times(1)).push(mockGit);
    }

    @Test
    public void itShouldsetUserInfo() {
        final String username = "johndoe@fake.com";
        final String fullname = "John Doe";

        SecurityUtil.UserInfo userInfo = new SecurityUtil.UserInfo(username, fullname);
        when(mockSecurityUtil.getUserInfo()).thenReturn(userInfo);

        when(mockRepository.getConfig()).thenReturn(mockConfig);
        when(mockGit.getRepository()).thenReturn(mockRepository);

        client.setUserInfo(mockGit);

        verify(mockConfig, times(1)).setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, fullname);
        verify(mockConfig, times(1)).setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, username);
    }

    @Test
    public void itShouldCloneRemoteRepository() throws GitAPIException {
        setMocksForCloneRepository();

        spyClient.cloneRemoteRepository(gitTestUtil.getGitLabProject());

        assertCloneRepository();
    }

    @Test
    public void itShouldCloneRepository() throws GitAPIException {
        setMocksForCloneRepository();

        final Git git = spyClient.cloneRepository(gitTestUtil.getGitLabProject());

        assertThat(git).isEqualTo(mockGit);
        assertCloneRepository();
    }

    private void setMocksForCloneRepository() throws GitAPIException {
        when(mockCloneCommand.setURI(anyString())).thenReturn(mockCloneCommand);

        when(mockCloneCommand.setDirectory(any(File.class))).thenReturn(mockCloneCommand);

        when(mockCloneCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class)))
            .thenReturn(mockCloneCommand);

        when(mockCloneCommand.call()).thenReturn(mockGit);

        when(spyClient.cloneCommand()).thenReturn(mockCloneCommand);
    }

    private void assertCloneRepository() throws GitAPIException {
        verify(mockCloneCommand, times(1)).setURI(anyString());
        verify(mockCloneCommand, times(1)).setDirectory(any(File.class));
        verify(mockCloneCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockCloneCommand, times(1)).call();
    }

    @Test
    public void itShouldPush() throws GitAPIException {
        when(mockPushCommand.setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class))).thenReturn
            (mockPushCommand);
        when(mockGit.push()).thenReturn(mockPushCommand);

        client.push(mockGit);

        verify(mockPushCommand, times(1)).setCredentialsProvider(any(UsernamePasswordCredentialsProvider.class));
        verify(mockPushCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessagePresent() throws GitAPIException {
        final String message = "Test Commit Message";

        when(mockCommitCommand.setMessage(message)).thenReturn(mockCommitCommand);
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        client.commit(mockGit, Optional.of(message));

        verify(mockCommitCommand, times(1)).setMessage(message);
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldCommitWhenMessageNotPresent() throws GitAPIException {
        when(mockGit.commit()).thenReturn(mockCommitCommand);

        client.commit(mockGit, Optional.empty());

        verify(mockCommitCommand, never()).setMessage(anyString());
        verify(mockCommitCommand, times(1)).call();
    }

    @Test
    public void itShouldAddReadMe() throws GitAPIException {
        when(mockAddCommand.addFilepattern(README_FILE)).thenReturn(mockAddCommand);
        when(mockGit.add()).thenReturn(mockAddCommand);

        client.addReadMe(mockGit);

        verify(mockAddCommand, times(1)).addFilepattern(README_FILE);
        verify(mockAddCommand, times(1)).call();
    }

    @Test
    public void itShouldWriteReadMeFileToLocalGitRepository() {
        client.writeReadMeToLocalRepo(gitTestUtil.getGitLabProject());
        assertThat(new File(gitTestUtil.getLocalRepoDir().toString() + "/" + README_FILE).isFile())
            .isEqualTo(true);
    }

    @Test
    public void itShouldGenerateRepositoryURI() {
        final String expected = String.format("%s/%s/%s.git",
            gitTestUtil.getGitlabHost(),
            gitTestUtil.getGitlabGroup(),
            gitTestUtil.getGitLabProject());

        final String actual = client.generateRepositoryURI(gitTestUtil.getGitLabProject());

        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void itShouldDeleteDirectory() {
        // setup creates the directories
        assertThat(Files.exists(gitTestUtil.getLocalRepoDir())).isEqualTo(true);
        assertThat(Files.isDirectory(gitTestUtil.getLocalRepoDir())).isEqualTo(true);

        client.deleteDirectory(gitTestUtil.getLocalRepoDir());

        assertThat(Files.exists(gitTestUtil.getLocalRepoDir())).isEqualTo(false);
    }

}
