/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.util;

import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.util.ValidationException;
import org.opentestsystem.ap.ims.model.AslFile;
import org.opentestsystem.ap.ims.model.BrailleFile;
import org.opentestsystem.ap.ims.model.UploadedFile;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.apache.commons.lang3.StringUtils.equalsIgnoreCase;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.split;

/**
 * Utility for working with braille files.
 */
@Component
public class AslFileUtil {

    private static final String ASL_TYPE_BRF = "BRF";

    private static final String ASL_TYPE_PRN = "PRN";

    private static final String ASL_NAMING_PATTERN = "^([Ss]tim|[Ii]tem|[Pp]assage)_(\\w+)_(enu)_(" +
        "([UuEe][XxCc][NnTtLl])|uncontracted|contracted|nemeth)(_transcript)*\\.(brf|prn)";

    private static final Pattern PATTERN = Pattern.compile(ASL_NAMING_PATTERN);

    /**
     * Creates an {@link Attachment} instance from a {@link AslFile}.  It is mapping an IMS model to the common
     * model.
     *
     * @param aslFile The file details being uploaded.
     * @return An {@link Attachment} instance.
     */
    public Attachment newAttachment(final AslFile aslFile) {
        final Attachment attachment = new Attachment();
        attachment.setFileName(aslFile.getFileName());
        attachment.setType(aslFile.getType());
        attachment.setSubtype(aslFile.getSubtype());
        attachment.setLanguage(aslFile.getLanguage());
        return attachment;
    }

    /**
     * Compares the request data like the submitted item against the asl file name (i.e. the AslFile). The item
     * in the request should match the item identified in the asl file name.
     *
     * @param itemId      The item the request is attempt to attach a asl file to.
     * @param aslFile       The asl file data being uploaded.
     */
    public void validateAslFile(final String itemId, final AslFile aslFile) {
        if (!equalsIgnoreCase(itemId, aslFile.getItemId())) {
            throw new ValidationException("The uploaded file does not have the correct item ID.  Expected " + itemId +
                " but received " + aslFile.getItemId());
        }
    }

    /**
     * Using the file name an instance of {@link AslFile} is created.  A file name is expected in a specific format.
     * It is assumed the file name format has been validated prior to calling this method.
     * <p>
     * <p>
     * "stim_8393_enu_contracted_transcript.brf" and "stim_8393_enu_contracted.brf" are examples of valid braille file
     * names.  The file name contains the different parts making up a {@link AslFile}
     *
     * @param fileName The file name to parse for the braille file data.
     * @return A {@link AslFile} instance.
     */
    public AslFile newAslFile(final String fileName) {
        if (fileName == null) {
            throw new ValidationException("File name cannot be null");
        }

        // first split on the extension
        final String[] splitOnExtension = split(fileName, ".");

        final String aslType = equalsIgnoreCase(splitOnExtension[1], ASL_TYPE_BRF.toLowerCase()) ?
            ASL_TYPE_BRF : ASL_TYPE_PRN;

        final String[] splitOnName = split(splitOnExtension[0], "_");

        final AslFile aslFile = new AslFile();
        aslFile.setFileName(fileName);
        aslFile.setType(aslType);
        aslFile.setItemId(splitOnName[1]);
        aslFile.setItemType(splitOnName[0]);
        aslFile.setLanguage(splitOnName[2]);

        if (splitOnName.length == 5) {
            aslFile.setSubtype(splitOnName[3] + "_" + splitOnName[4]);
        } else {
            aslFile.setSubtype(splitOnName[3]);
        }

        return aslFile;
    }

    /**
     * Validate the upload request.  A validation error results in throwing a {@link ValidationException}
     *
     * @param uploadedFile The request data to validate.
     */
    public void validateUploadedFile(UploadedFile uploadedFile) {
        if (uploadedFile == null) {
            throw new ValidationException("No data in file upload request");
        }

        if (isBlank(uploadedFile.getItemId())) {
            throw new ValidationException("Item ID cannot be blank in upload request");
        }

        if (isBlank(uploadedFile.getTransactionId())) {
            throw new ValidationException("Transaction ID cannot be blank in upload request");
        }

        final MultipartFile file = uploadedFile.getFile();
        if (file == null || file.isEmpty()) {
            throw new ValidationException("No file found in upload request");
        }

        validateFileName(file.getOriginalFilename());
    }

    /**
     * Validates the braille filename matches a pre-defined pattern.
     *
     * @param fileName The filename to validate.
     * @return True if the filename is valid, false otherwise.
     */
    public void validateFileName(String fileName) {
        final Matcher matcher = PATTERN.matcher(fileName);
        if (!matcher.matches()) {
            throw new ValidationException("The file name is not in the correct format");
        }
    }

}
