/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.opentestsystem.ap.ims.client;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;

import com.google.common.annotations.VisibleForTesting;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.errors.RepositoryNotFoundException;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.CredentialsProvider;
import org.eclipse.jgit.transport.RefSpec;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.ap.ims.config.ItemBankProperties;
import org.opentestsystem.ap.ims.entity.ItemBankUser;
import org.opentestsystem.ap.ims.util.ItemAssembler;
import org.opentestsystem.ap.ims.util.SystemException;
import org.opentestsystem.saaif.item.ItemRelease;

import static java.lang.System.out;

/**
 * A GIT client using JGit.
 * <p>
 * It is expected one will use {@link GitClientFactory} to instantiate an instance of this
 * class.  The name of the repository to work with is given to the factory.  Once there
 * is an instance of this class it can be used to interact with that repository.  The
 * main point is an instance of this class is not stateless.  If you need to work with two different
 * repositories you need create two different instances of this class.
 * </p>
 * <p>
 * The methods in this class are primarily Git commands.  The methods try to do one
 * thing and one thing only, for the most part.  It is up to the user
 * to use these commands in the order that works for them.  For example, one could switch
 * to master branch, pull the latest, and then push. That would be three calls
 * to this class, one for each of those commands.
 * </p>
 */
@Slf4j
public class GitClient {

    public static final String GIT_CONFIG_USER = "user";

    public static final String GIT_CONFIG_USER_NAME = "name";

    public static final String GIT_CONFIG_USER_EMAIL = "email";

    public static final String SCRATCH_PAD = "scratch-pad";

    public static final String BRANCH_MASTER = "master";

    private final ItemBankProperties itemBankProperties;

    private final ItemBankUser userInfo;

    private final CredentialsProvider credentialsProvider;

    private final String repository;

    private final ItemAssembler itemAssembler;

    private Git git;

    /**
     * The constructor is package private. {@link GitClientFactory} instantiates it.  Using the factor
     * is the preferred way to instantiate an instance.  The reason is the factory then calls a method
     * to initialize the client with a local repository.  Usage of the client from that point is correctly
     * setup and initialized.
     *
     * @param itemBankProperties The properties
     * @param userInfo           The user making the request.
     * @param repository         The name of the repository to work with.
     * @param itemAssembler      The item assembler.
     */
    GitClient(ItemBankProperties itemBankProperties, ItemBankUser userInfo, String repository, ItemAssembler
        itemAssembler) {
        this.itemBankProperties = itemBankProperties;
        this.userInfo = userInfo;
        this.repository = repository;
        this.itemAssembler = itemAssembler;
        this.credentialsProvider = new UsernamePasswordCredentialsProvider(
            itemBankProperties.getUser(), itemBankProperties.getPassword());
    }

    // ------------------------------------------------------------------------

    /**
     * Deletes the scratchpad branch locally and remotely.  The local branch is deleted with
     * the force property set to TRUE.
     */
    public void deleteScratchPad() {
        deleteRemoteBranch(userInfo.getUsername());
        deleteLocalBranch(userInfo.getUsername());
    }

    public void deleteRemoteBranch(String branchToDelete) {
        try {
            final RefSpec refSpec = newRefSpec().setSource(null).setDestination("refs/heads/" + branchToDelete);
            git.push().setCredentialsProvider(credentialsProvider).setRefSpecs(refSpec).setRemote("origin").call();
        } catch (GitAPIException e) {
            throw new SystemException("Error deleting the scratchpad branch " + branchToDelete, e);
        }
    }

    public void deleteLocalBranch(String branchToDelete) {
        try {
            git.branchDelete().setBranchNames(branchToDelete).setForce(true).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error deleting the scratchpad branch " + branchToDelete, e);
        }
    }

    /**
     * Merge scratch pad branch into the currently checked out local branch.  The scratch
     * pad remote branch is what gets merged.
     */
    public void mergeScratchPad() {
        pullRemoteBranchIntoCurrentLocal(userInfo.getUsername());
    }

    /**
     * Pull changes from remote to the local.  The currently checked out
     * branch is what is pulled from and into.
     */
    public void pullLatest() {
        try {
            git.pull().setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error pulling latest changes from remote to local", e);
        }
    }

    /**
     * Check out the master branch.
     */
    public void checkoutMasterBranch() {
        checkoutBranch(BRANCH_MASTER);
    }

    /**
     * Check out the scratch pad branch.
     */
    public void checkoutScratchPad() {
        checkoutBranch(userInfo.getUsername());
    }

    /**
     * Creates a new branch off the currently checked out branch.  If you want to branch from master
     * make sure you have first checked out master.
     */
    public void createScratchPad() {
        try {
            git.branchCreate().setName(userInfo.getUsername()).call();
            git.checkout().setName(userInfo.getUsername()).call();
        } catch (GitAPIException e) {
            throw new SystemException("Problem creating scratch pad branch", e);
        }
    }

    /**
     * Pushes local pending commits to the remote repository.
     */
    public void push() {
        try {
            git.push().setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error pushing changes", e);
        }
    }

    /**
     * Commits what has been staged in the local repository.
     *
     * @param message The optional commit message.
     */
    public void commit(String message) {
        final CommitCommand commit = git.commit();
        try {
            if (StringUtils.isNotBlank(message)) {
                commit.setMessage(message);
            }
            commit.call();
        } catch (GitAPIException e) {
            throw new SystemException("Error during initial commit", e);
        }
    }

    /**
     * Stages the item file.
     */
    public void stageItemFile() {
        stageFiles(generateItemFileName());
    }

    public void stageFiles(String filePattern) {
        final AddCommand add = git.add();
        try {
            add.addFilepattern(filePattern).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error staging files.", e);
        }
    }

    /**
     * Writes the item to the local repository in XML format.
     *
     * @param item The item to write to a file.
     */
    public void writeItemFile(ItemRelease item) {
        final String itemFilePath = generateLocalFilePath(generateItemFileName());
        log.debug("generate item file {}", itemFilePath);
        itemAssembler.writeXmlToFile(item, Paths.get(itemFilePath));
    }

    /**
     * Reads the item file.  This is the SAAIF xml representation of the item.
     *
     * @return The item instance created from reading the item file.
     */
    public ItemRelease readItemFile() {
        final String itemFilePath = generateLocalFilePath(generateItemFileName());
        log.debug("generate item file {}", itemFilePath);
        return itemAssembler.readXmlFromFile(Paths.get(itemFilePath));
    }

    // ------------------------------------------------------------------------

    /**
     * Attempts to open a local instance of the repository.  If the local instance
     * does not exist then it is cloned from the remote host.
     */
    void openOrClone() {
        try {
            git = openRepository();
        } catch (RepositoryNotFoundException e) {
            git = cloneRepository();
        } catch (IOException e) {
            throw new SystemException("Error opening repository " + repository, e);
        }
        // when setting the 'git' property always set userInfo on it
        setUserInfo();
    }

    /**
     * Clones the remote repository.
     */
    void cloneRemoteRepository() {
        git = cloneRepository();
        // when setting the 'git' property always set userInfo on it
        setUserInfo();
    }

    /**
     * Opens a local instance of the repository.  If the local repository does
     * not exist a {@link RepositoryNotFoundException} is thrown.
     *
     * @return A reference to the local repository.
     * @throws IOException
     */
    Git openRepository() throws IOException {
        return Git.open(new File(itemBankProperties.getLocalBaseDir() + "/" + repository));
    }

    /**
     * Clones the given repository where the repository URI is built with an expected format
     * matching an existing remote repository.  The remote repository is cloned locally at
     * a pre-configured location.  Credentials are required and should be provided by the
     * gitlab properties instance on the class.
     *
     * @return The git instance referencing the cloned repository.
     */
    @VisibleForTesting
    Git cloneRepository() {
        final String repositoryURI = generateRepositoryURI(repository);

        log.debug("repositoryURI is {}", repositoryURI);

        final Git git;
        try {
            git = cloneCommand()
                .setURI(repositoryURI)
                .setDirectory(new File(itemBankProperties.getLocalBaseDir() + "/" + repository))
                .setCredentialsProvider(credentialsProvider)
                .call();

        } catch (GitAPIException e) {
            throw new SystemException("Error cloning repository " + repository, e);
        }
        return git;
    }

    /**
     * Sets the user's info on the git client.  The properties set are the common
     * git configuration properties email and user's name.
     */
    @VisibleForTesting
    void setUserInfo() {
        log.debug("setting user info on the client");
        // TODO What about multiple threads, is this thread safe
        final StoredConfig config = git.getRepository().getConfig();
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, userInfo.getUsername());
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, userInfo.getFullname());
    }

    /**
     * Pull changes from the given remote branch into the current locally checked out branch.  One might
     * pull a remote feature branch into the local master branch in which case the currently checked out local
     * branch is master.
     *
     * @param remoteBranchToPull The remote branch to pull changes from.
     */
    @VisibleForTesting
    void pullRemoteBranchIntoCurrentLocal(String remoteBranchToPull) {
        try {
            git.pull().setCredentialsProvider(credentialsProvider).setRemoteBranchName(remoteBranchToPull).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error merging scratch pad into master", e);
        }
    }

    /**
     * Checkout the given branch.
     *
     * @param branchName The branch to checkout.
     */
    @VisibleForTesting
    void checkoutBranch(String branchName) {
        try {
            git.checkout().setName(branchName).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error checking out branch " + branchName, e);
        }
    }

    /**
     * The expected URI format to a given repository
     * <fieldName>http://{host}:{port}/{groupName}/{repository}.git</fieldName>
     * <p>
     * A common use for this value is cloning a remote repository.
     *
     * @param repository
     * @return The URI to the remote git repository.
     */
    @VisibleForTesting
    String generateRepositoryURI(String repository) {
        return String.format("%s/%s/%s.git",
            itemBankProperties.getHost(), itemBankProperties.getGroup(), repository);
    }

    @VisibleForTesting
    String generateLocalFilePath(String fileName) {
        return String.format("%s/%s/%s", itemBankProperties.getLocalBaseDir(), repository,
            fileName);
    }

    @VisibleForTesting
    String generateItemFileName() {
        return String.format("item-%s.xml", repository);
    }

    /**
     * Deletes the given path and all the contents within it.  If the path is not
     * a directory or the path does not exist then nothing happens.  There is no error
     * thrown and no files are deleted.
     *
     * @param directoryToDelete The directory to delete.
     */
    @VisibleForTesting
    void deleteDirectory(Path directoryToDelete) {
        if (Files.exists(directoryToDelete) && Files.isDirectory(directoryToDelete)) {
            try {
                Files.walk(directoryToDelete, FileVisitOption.FOLLOW_LINKS)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .peek(out::println)
                    .forEach(File::delete);
            } catch (Exception e) {
                throw new SystemException("Error trying to delete a directory", e);
            }
        }
    }

    @VisibleForTesting
    CloneCommand cloneCommand() {
        return Git.cloneRepository();
    }

    RefSpec newRefSpec() {
        return new RefSpec();
    }

    @VisibleForTesting
    void setGit(Git git) {
        this.git = git;
    }
}
