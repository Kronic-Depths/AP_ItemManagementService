/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import com.google.common.annotations.VisibleForTesting;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.errors.RepositoryNotFoundException;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.CredentialsProvider;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.ap.ims.config.GitlabProperties;
import org.opentestsystem.ap.ims.entity.ItemBankUser;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;

import static java.lang.System.out;

/**
 * A GIT client using JGit.  The client is built around a GitLab group.
 * An instance of this repository operates within a group.  Cloned repositories
 * are expected to exist under the group in GitLab.
 */
@Slf4j
public class GitClient {

    public static final String GIT_CONFIG_USER = "user";

    public static final String GIT_CONFIG_USER_NAME = "name";

    public static final String GIT_CONFIG_USER_EMAIL = "email";

    public static final String SCRATCH_PAD = "scratch-pad";

    public static final String README_FILE = "README.md";

    private final GitlabProperties gitlabProperties;

    private final ItemBankUser userInfo;

    private final CredentialsProvider credentialsProvider;

    private final String repository;

    private Git git;

    @VisibleForTesting
    GitClient(GitlabProperties gitlabProperties, ItemBankUser userInfo, String repository) {
        this.gitlabProperties = gitlabProperties;
        this.userInfo = userInfo;
        this.repository = repository;
        this.credentialsProvider = new UsernamePasswordCredentialsProvider(
            gitlabProperties.getUser(), gitlabProperties.getPassword());
    }

    // ------------------------------------------------------------------------

    public void openOrClone() {
        try {
            git = openRepository();
        } catch (RepositoryNotFoundException e) {
            git = cloneRepository();
        } catch (IOException e) {
            throw new RuntimeException("Error opening repository " + repository, e);
        }
        setUserInfo();
    }

    public void cloneRemoteRepository() {
        git = cloneRepository();
        setUserInfo();
    }

    public boolean checkScratchPadExist() {
        openOrClone();
        return checkScratchPadBranchExist();
    }

    public void createScratchPad() {
        try {
            git.branchCreate().setName(SCRATCH_PAD).call();
            git.checkout().setName(SCRATCH_PAD).call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Problem creating scratch pad branch", e);
        }
    }

    /**
     * Pushes local pending commits to the remote repository.
     */
    public void push() {
        final PushCommand push = git.push();
        try {
            push.setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Error pushing changes", e);
        }
    }

    /**
     * Commits what has been staged in the local repository.
     *
     * @param message The optional commit message.
     */
    public void commit(String message) {
        final CommitCommand commit = git.commit();
        try {
            if (StringUtils.isNotBlank(message)) {
                commit.setMessage(message);
            }
            commit.call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Error during initial commit", e);
        }
    }

    /**
     * Expects a README.md file to exist in the given git instance.  The git
     * instances represents a local get repository.
     */
    public void addReadMe() {
        addFiles(git, README_FILE);
    }

    public void addItemFile() {
        addFiles(git, "item-" + repository + ".xml");
    }

    public void addFiles(Git git, String filePattern) {
        final AddCommand add = git.add();
        try {
            add.addFilepattern(filePattern).call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Error adding README file", e);
        }
    }

    /**
     * Writes a README.md file to the local repository.  The README file is empty.
     */
    public void writeEmptyReadMe() {
        final String readmeFilePath = generateLocalFilePath(README_FILE);

        log.debug("generate readme {}", readmeFilePath);

        try {
            Files.createFile(Paths.get(readmeFilePath));
        } catch (IOException e) {
            throw new RuntimeException("Error generating readme for repository " + repository, e);
        }
    }

    public void writeItemFile() {
        final String itemFilePath = generateLocalFilePath("item-" + repository + ".xml");

        log.debug("generate item file {}", itemFilePath);

        try {
            Files.createFile(Paths.get(itemFilePath));
        } catch (IOException e) {
            throw new RuntimeException("Error generating readme for repository " + repository, e);
        }
    }

    // ------------------------------------------------------------------------

    Git openRepository() throws IOException {
        return Git.open(new File(gitlabProperties.getLocalBaseDir() + "/" + repository));
    }

    /**
     * Clones the given repository where the repository URI is built with an expected format
     * matching an existing remote repository.  The remote repository is cloned locally at
     * a pre-configured location.  Credentials are required and should be provided by the
     * gitlab properties instance on the class.
     *
     * @return The git instance referencing the cloned repository.
     */
    @VisibleForTesting
    Git cloneRepository() {
        final String repositoryURI = generateRepositoryURI(repository);

        log.debug("repositoryURI is {}", repositoryURI);

        final Git git;
        try {
            git = cloneCommand()
                .setURI(repositoryURI)
                .setDirectory(new File(gitlabProperties.getLocalBaseDir() + "/" + repository))
                .setCredentialsProvider(credentialsProvider)
                .call();

        } catch (GitAPIException e) {
            throw new RuntimeException("Error cloning repository " + repository, e);
        }
        return git;
    }

    @VisibleForTesting
    void setUserInfo() {
        log.debug("setting user info on the Git session");

        // TODO What about multiple threads, is this thread safe
        final StoredConfig config = git.getRepository().getConfig();
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, userInfo.getUsername());
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, userInfo.getFullname());
    }

    boolean checkScratchPadBranchExist() {
        boolean exists = false;
        Collection<Ref> heads = Collections.emptyList();
        try {
            heads = git.lsRemote().setCredentialsProvider(credentialsProvider).setHeads(true).call();
            if (heads != null && !heads.isEmpty()) {
                for (Ref head : heads) {
                    out.println(head.getName());
                    if (head.getName().endsWith(SCRATCH_PAD)) {
                        exists = true;
                        break;
                    }
                }
            }
        } catch (GitAPIException e) {
            throw new RuntimeException("Problem calling ls-remote on repository", e);
        }
        return exists;
    }

    /**
     * The expected URI format to a given repository
     * <code>http://{host}:{port}/{groupName}/{repository}.git</code>
     * <p>
     * A common use for this value is cloning a remote repository.
     *
     * @param repository
     * @return The URI to the remote git repository.
     */
    @VisibleForTesting
    String generateRepositoryURI(String repository) {
        return String.format("%s/%s/%s.git",
            gitlabProperties.getHost(), gitlabProperties.getGroup(), repository);
    }

    @VisibleForTesting
    String generateLocalFilePath(String fileName) {
        return String.format("%s/%s/%s", gitlabProperties.getLocalBaseDir(), repository,
            fileName);
    }

    @VisibleForTesting
    String generateItemFile() {
        return String.format("item-%s.xml", repository);
    }

    /**
     * Deletes the given path and all the contents within it.  If the path is not
     * a directory or the path does not exist then nothing happens.  There is no error
     * thrown and not files are deleted.
     *
     * @param directoryToDelete The directory to delete.
     */
    @VisibleForTesting
    void deleteDirectory(Path directoryToDelete) {
        if (Files.exists(directoryToDelete) && Files.isDirectory(directoryToDelete)) {
            try {
                Files.walk(directoryToDelete, FileVisitOption.FOLLOW_LINKS)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .peek(out::println)
                    .forEach(File::delete);
            } catch (Exception e) {
                throw new RuntimeException("Error trying to delete a directory", e);
            }
        }
    }

    @VisibleForTesting
    CloneCommand cloneCommand() {
        return Git.cloneRepository();
    }

    @VisibleForTesting
    void setGit(Git git) {
        this.git = git;
    }

}
