/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import com.google.common.annotations.VisibleForTesting;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.errors.RepositoryNotFoundException;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.CredentialsProvider;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.ap.ims.config.ItemBankProperties;
import org.opentestsystem.ap.ims.util.ItemAssembler;
import org.opentestsystem.ap.ims.entity.ItemBankUser;
import org.opentestsystem.ap.ims.util.SystemException;
import org.opentestsystem.saaif.item.ItemRelease;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;

import static java.lang.System.out;

/**
 * A GIT client using JGit. Cloned repositories are expected to exist under the group in GitLab.
 */
@Slf4j
public class GitClient {

    public static final String GIT_CONFIG_USER = "user";

    public static final String GIT_CONFIG_USER_NAME = "name";

    public static final String GIT_CONFIG_USER_EMAIL = "email";

    public static final String SCRATCH_PAD = "scratch-pad";

    public static final String README_FILE = "README.md";

    private final ItemBankProperties itemBankProperties;

    private final ItemBankUser userInfo;

    private final CredentialsProvider credentialsProvider;

    private final String repository;

    private final ItemAssembler itemAssembler;

    private Git git;

    /**
     * The constructor is package private. {@link GitClientFactory} instantiates it.  Using the factor
     * is the preferred way to instantiate an instance.  The reason is the factory then calls a method
     * to initialize the client with a local repository.  Usage of the client from that point is correctly
     * setup and initialized.
     *
     * @param itemBankProperties The properties
     * @param userInfo         The user making the request.
     * @param repository       The name of the repository to work with.
     * @param itemAssembler
     */
    GitClient(ItemBankProperties itemBankProperties, ItemBankUser userInfo, String repository, ItemAssembler
        itemAssembler) {
        this.itemBankProperties = itemBankProperties;
        this.userInfo = userInfo;
        this.repository = repository;
        this.itemAssembler = itemAssembler;
        this.credentialsProvider = new UsernamePasswordCredentialsProvider(
            itemBankProperties.getUser(), itemBankProperties.getPassword());
    }

    // ------------------------------------------------------------------------

    public boolean checkScratchPadExist() {
        openOrClone();
        return checkScratchPadBranchExist();
    }

    public void createScratchPad() {
        try {
            git.branchCreate().setName(SCRATCH_PAD).call();
            git.checkout().setName(SCRATCH_PAD).call();
        } catch (GitAPIException e) {
            throw new SystemException("Problem creating scratch pad branch", e);
        }
    }

    /**
     * Pushes local pending commits to the remote repository.
     */
    public void push() {
        final PushCommand push = git.push();
        try {
            push.setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error pushing changes", e);
        }
    }

    /**
     * Commits what has been staged in the local repository.
     *
     * @param message The optional commit message.
     */
    public void commit(String message) {
        final CommitCommand commit = git.commit();
        try {
            if (StringUtils.isNotBlank(message)) {
                commit.setMessage(message);
            }
            commit.call();
        } catch (GitAPIException e) {
            throw new SystemException("Error during initial commit", e);
        }
    }

    /**
     * Expects a README.md file to exist in the given git instance.  The git
     * instances represents a local get repository.
     */
    public void stageReadme() {
        stageFiles(README_FILE);
    }

    /**
     * Stages the item file.
     */
    public void stageItemFile() {
        stageFiles(generateItemFileName());
    }

    public void stageFiles(String filePattern) {
        final AddCommand add = git.add();
        try {
            add.addFilepattern(filePattern).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error adding README file", e);
        }
    }

    /**
     * Writes a README.md file to the local repository.  The README file is empty.
     */
    public void writeEmptyReadMe() {
        final String readmeFilePath = generateLocalFilePath(README_FILE);
        log.debug("generate readme {}", readmeFilePath);
        try {
            Files.createFile(Paths.get(readmeFilePath));
        } catch (IOException e) {
            throw new SystemException("Error generating readme for repository " + repository, e);
        }
    }

    /**
     * Writes the item to the local repository in XML format.
     *
     * @param item The item to write to a file.
     */
    public void writeItemFile(ItemRelease item) {
        final String itemFilePath = generateLocalFilePath(generateItemFileName());
        log.debug("generate item file {}", itemFilePath);
        itemAssembler.writeXmlToFile(item, Paths.get(itemFilePath));
    }

    public ItemRelease readItemFile() {
        final String itemFilePath = generateLocalFilePath(generateItemFileName());
        log.debug("generate item file {}", itemFilePath);
        return itemAssembler.readXmlFromFile(Paths.get(itemFilePath));
    }

    // ------------------------------------------------------------------------

    /**
     * Attempts to open a local instance of the repository.  If the local instance
     * does not exist then it is cloned from the remote host.
     */
    void openOrClone() {
        try {
            git = openRepository();
        } catch (RepositoryNotFoundException e) {
            git = cloneRepository();
        } catch (IOException e) {
            throw new SystemException("Error opening repository " + repository, e);
        }
        // when setting the 'git' property always set userInfo on it
        setUserInfo();
    }

    /**
     * Clones the remote repository.
     */
    void cloneRemoteRepository() {
        git = cloneRepository();
        // when setting the 'git' property always set userInfo on it
        setUserInfo();
    }

    /**
     * Opens a local instance of the repository.  If the local repository does
     * not exist a {@link RepositoryNotFoundException} is thrown.
     *
     * @return A reference to the local repository.
     * @throws IOException
     */
    Git openRepository() throws IOException {
        return Git.open(new File(itemBankProperties.getLocalBaseDir() + "/" + repository));
    }

    /**
     * Clones the given repository where the repository URI is built with an expected format
     * matching an existing remote repository.  The remote repository is cloned locally at
     * a pre-configured location.  Credentials are required and should be provided by the
     * gitlab properties instance on the class.
     *
     * @return The git instance referencing the cloned repository.
     */
    @VisibleForTesting
    Git cloneRepository() {
        final String repositoryURI = generateRepositoryURI(repository);

        log.debug("repositoryURI is {}", repositoryURI);

        final Git git;
        try {
            git = cloneCommand()
                .setURI(repositoryURI)
                .setDirectory(new File(itemBankProperties.getLocalBaseDir() + "/" + repository))
                .setCredentialsProvider(credentialsProvider)
                .call();

        } catch (GitAPIException e) {
            throw new SystemException("Error cloning repository " + repository, e);
        }
        return git;
    }

    @VisibleForTesting
    void setUserInfo() {
        log.debug("setting user info on the client");
        // TODO What about multiple threads, is this thread safe
        final StoredConfig config = git.getRepository().getConfig();
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, userInfo.getUsername());
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, userInfo.getFullname());
    }

    boolean checkScratchPadBranchExist() {
        boolean exists = false;
        Collection<Ref> heads = Collections.emptyList();
        try {
            heads = git.lsRemote().setCredentialsProvider(credentialsProvider).setHeads(true).call();
            if (heads != null && !heads.isEmpty()) {
                for (Ref head : heads) {
                    out.println(head.getName());
                    if (head.getName().endsWith(SCRATCH_PAD)) {
                        exists = true;
                        break;
                    }
                }
            }
        } catch (GitAPIException e) {
            throw new SystemException("Problem calling ls-remote on repository", e);
        }
        return exists;
    }

    /**
     * The expected URI format to a given repository
     * <fieldName>http://{host}:{port}/{groupName}/{repository}.git</fieldName>
     * <p>
     * A common use for this value is cloning a remote repository.
     *
     * @param repository
     * @return The URI to the remote git repository.
     */
    @VisibleForTesting
    String generateRepositoryURI(String repository) {
        return String.format("%s/%s/%s.git",
            itemBankProperties.getHost(), itemBankProperties.getGroup(), repository);
    }

    @VisibleForTesting
    String generateLocalFilePath(String fileName) {
        return String.format("%s/%s/%s", itemBankProperties.getLocalBaseDir(), repository,
            fileName);
    }

    @VisibleForTesting
    String generateItemFileName() {
        return String.format("item-%s.xml", repository);
    }

    /**
     * Deletes the given path and all the contents within it.  If the path is not
     * a directory or the path does not exist then nothing happens.  There is no error
     * thrown and no files are deleted.
     *
     * @param directoryToDelete The directory to delete.
     */
    @VisibleForTesting
    void deleteDirectory(Path directoryToDelete) {
        if (Files.exists(directoryToDelete) && Files.isDirectory(directoryToDelete)) {
            try {
                Files.walk(directoryToDelete, FileVisitOption.FOLLOW_LINKS)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .peek(out::println)
                    .forEach(File::delete);
            } catch (Exception e) {
                throw new SystemException("Error trying to delete a directory", e);
            }
        }
    }

    @VisibleForTesting
    CloneCommand cloneCommand() {
        return Git.cloneRepository();
    }

    @VisibleForTesting
    void setGit(Git git) {
        this.git = git;
    }
}
