/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.CreateBranchCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.RefNotFoundException;
import org.eclipse.jgit.errors.RepositoryNotFoundException;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.CredentialsProvider;
import org.eclipse.jgit.transport.RefSpec;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.ap.ims.config.ItemBankProperties;
import org.opentestsystem.ap.ims.entity.ItemBankUser;
import org.opentestsystem.ap.ims.util.SaaifAssembler;
import org.opentestsystem.ap.ims.util.SystemException;
import org.opentestsystem.saaif.item.ItemRelease;

import static org.eclipse.jgit.api.ListBranchCommand.ListMode.REMOTE;

/**
 * A GIT client using JGit.
 * <p>
 * It is expected one will use {@link GitClientFactory} to instantiate an instance of this
 * class.  The name of the repository to work with is given to the factory.  Once there
 * is an instance of this class it can be used to interact with that repository.  The
 * main point is an instance of this class is not stateless.  If you need to work with two different
 * repositories you need create two different instances of this class.
 * </p>
 * <p>
 * The methods in this class are primarily Git commands.  The methods try to do one
 * thing and one thing only, for the most part.  It is up to the user
 * to use these commands in the order that works for them.  For example, one could switch
 * to master branch, pull the latest, and then push. That would be three calls
 * to this class, one for each of those commands.
 * </p>
 */
@Slf4j
public class GitClient {

    public static final String GIT_CONFIG_USER = "user";

    public static final String GIT_CONFIG_USER_NAME = "name";

    public static final String GIT_CONFIG_USER_EMAIL = "email";

    public static final String ORIGIN = "origin";

    public static final String SCRATCH_PAD = "ScratchPad";

    public static final String BRANCH_MASTER = "master";

    private static final String REMOTE_SCRATCH_PAD_PATH = "refs/remotes/origin/" + SCRATCH_PAD + "_";

    private final ItemBankProperties itemBankProperties;

    private final ItemBankUser userInfo;

    private final CredentialsProvider credentialsProvider;

    private final String repository;

    private final SaaifAssembler saaifAssembler;

    private Git git;

    private String parsedUsername;

    /**
     * The constructor is package private. {@link GitClientFactory} instantiates it.  Using the factor
     * is the preferred way to instantiate an instance.  The reason is the factory then calls a method
     * to initialize the client with a local repository.  Usage of the client from that point is correctly
     * setup and initialized.
     *
     * @param itemBankProperties The properties
     * @param userInfo           The user making the request.
     * @param repository         The name of the repository to work with.
     * @param saaifAssembler     The item assembler.
     */
    GitClient(ItemBankProperties itemBankProperties, ItemBankUser userInfo, String repository, SaaifAssembler
        saaifAssembler) {
        this.itemBankProperties = itemBankProperties;
        this.userInfo = userInfo;
        this.parsedUsername = userInfo.parseUsername();
        this.repository = repository;
        this.saaifAssembler = saaifAssembler;
        this.credentialsProvider = new UsernamePasswordCredentialsProvider(
            itemBankProperties.getUser(), itemBankProperties.getPassword());
    }

    // ------------------------------------------------------------------------

    /**
     * Find the username of the scratch pad owner.
     *
     * @return The username of the scratch pad owner or null is there is no scratch pad.
     */
    public String findScratchPadOwner() {
        final List<String> scratchPadBranches = findScratchPadBranchNames();
        return scratchPadBranches.stream().map(name -> name.replace(REMOTE_SCRATCH_PAD_PATH, StringUtils.EMPTY))
            .findFirst().orElse(null);
    }

    /**
     * Find all branches containing the word "ScratchPad".
     *
     * @return A list of scratch pad branch names.  If there are no scratch pad branches an empty list is returned
     */
    public List<String> findScratchPadBranchNames() {
        return findRemoteBranchesContainingName(SCRATCH_PAD);
    }

    /**
     * Find all branches containing the given branchName.
     *
     * @param branchName The filter criteria when searching for branches.  The filter uses 'contains'.
     * @return A list of branches containing the given branchName.
     */
    public List<String> findRemoteBranchesContainingName(final String branchName) {
        List<String> branchNames = Collections.emptyList();
        // make sure local repository is up to date
        fetchLatest();
        try {
            final List<Ref> branches = git.branchList().setListMode(REMOTE).call();
            if (CollectionUtils.isNotEmpty(branches)) {
                branchNames = branches.stream().map(Ref::getName).filter(name -> name.contains(branchName)).collect
                    (Collectors.toList());
            }
        } catch (GitAPIException e) {
            throw new SystemException("Error listing all branches", e);
        }
        return branchNames;
    }

    /**
     * Fetch the latest remote repository data and remove references that no longer exists like deleted
     * branches.
     */
    public void fetchLatest() {
        try {
            git.fetch().setRemoveDeletedRefs(true).setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error listing all branches", e);
        }
    }

    /**
     * Deletes the scratchpad branch locally and remotely.  The local branch is deleted with
     * the force property set to TRUE.
     */
    public void deleteScratchPad() {
        final String scratchPadName = generateScratchPadName();
        deleteRemoteBranch(scratchPadName);
        deleteLocalBranch(scratchPadName);
    }

    /**
     * Delete the scratch pad branch in the remote repository.
     */
    public void deleteRemoteScratchPad() {
        final String scratchPadName = generateScratchPadName();
        deleteRemoteBranch(scratchPadName);
    }

    /**
     * Delete the scratch pad branch in the local repository.
     */
    public void deleteLocalScratchPad() {
        final String scratchPadName = generateScratchPadName();
        deleteLocalBranch(scratchPadName);
    }

    /**
     * Merge scratch pad branch into the currently checked out local branch.  The scratch
     * pad remote branch is what gets merged.
     */
    public void mergeScratchPad() {
        final String scratchPadName = generateScratchPadName();
        try {
            final Ref scratchPadRef = git.getRepository().findRef(scratchPadName);
            mergeAndCommit(scratchPadRef);
        } catch (IOException e) {
            throw new SystemException("Error getting reference to branch " + scratchPadName);
        }
    }

    /**
     * Pull changes from remote to the local.  The currently checked out
     * branch is what is pulled from and into.
     */
    public void pullLatest() {
        try {
            git.pull().setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error pulling latest changes from remote to local", e);
        }
    }

    /**
     * Check out the master branch.
     */
    public Ref checkoutMasterBranch() {
        return checkoutBranch(BRANCH_MASTER);
    }

    /**
     * Check out the scratch pad branch.
     */
    public Ref checkoutScratchPad() {
        final String scratchPadName = generateScratchPadName();
        return checkoutBranch(scratchPadName);
    }

    /**
     * Creates a new branch off the currently checked out branch.  If you want
     * to branch from master make sure you have first checked out master.
     */
    public void createScratchPad() {
        final String scratchPadName = generateScratchPadName();
        try {
            git.branchCreate().setName(scratchPadName).call();
            git.checkout().setName(scratchPadName).call();
        } catch (GitAPIException e) {
            throw new SystemException("Problem creating scratch pad branch", e);
        }
    }

    /**
     * Pushes local pending commits to the remote repository.
     */
    public void push() {
        try {
            git.push().setCredentialsProvider(credentialsProvider).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error pushing changes", e);
        }
    }

    /**
     * Commits what has been staged in the local repository.
     *
     * @param message The optional commit message.
     */
    public void commit(String message) {
        final CommitCommand commit = git.commit();
        try {
            if (StringUtils.isNotBlank(message)) {
                commit.setMessage(message);
            }
            commit.call();
        } catch (GitAPIException e) {
            throw new SystemException("Error during initial commit", e);
        }
    }

    /**
     * Stages the item file.
     */
    public void stageItemFile() {
        stageFiles(generateItemFileName());
    }

    public void stageFiles(String filePattern) {
        final AddCommand add = git.add();
        try {
            add.addFilepattern(filePattern).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error staging files.", e);
        }
    }

    /**
     * Writes the item to the local repository in XML format.
     *
     * @param item The item to write to a file.
     */
    public void writeItemFile(ItemRelease item) {
        final String itemFilePath = generateLocalFilePath(generateItemFileName());
        log.debug("generate item file {}", itemFilePath);
        saaifAssembler.writeXmlToFile(item, Paths.get(itemFilePath));
    }

    /**
     * Reads the item file.  This is the SAAIF xml representation of the item.
     *
     * @return The item instance created from reading the item file.
     */
    public ItemRelease readItemFile() {
        final String itemFilePath = generateLocalFilePath(generateItemFileName());
        log.debug("generate item file {}", itemFilePath);
        return saaifAssembler.readXmlFromFile(Paths.get(itemFilePath));
    }


    // ------------------------------------------------------------------------

    /**
     * Attempts to open a local instance of the repository.  If the local instance
     * does not exist then it is cloned from the remote host.
     */
    void openOrClone() {
        try {
            git = openRepository();
            // pull from remote to guarantee being up to date
            // multiple service instance means the user
            // can make changes on different local repos,
            // they are not guaranteed the same local repo
            git.pull();
        } catch (RepositoryNotFoundException e) {
            git = cloneRepository();
        } catch (IOException e) {
            throw new SystemException("Error opening repository " + repository, e);
        }
        // when setting the 'git' property always set userInfo on it
        setUserInfo();
    }

    /**
     * Clones the remote repository.  Only the master branch will exist locally once the clone completes.
     * Cloning a specific branch in a separate call is required to get any other branch cloned.
     */
    void cloneRemoteRepository() {
        git = cloneRepository();
        setUserInfo();
    }

    /**
     * Opens a local instance of the repository.  If the local repository does
     * not exist a {@link RepositoryNotFoundException} is thrown.
     *
     * @return A reference to the local repository.
     * @throws IOException
     */
    Git openRepository() throws IOException {
        return Git.open(new File(generateLocalRepoPath()));
    }

    /**
     * Clones the given repository where the repository URI is built with an expected format
     * matching an existing remote repository.  The remote repository is cloned locally at
     * a pre-configured location.  Credentials are required and should be provided by the
     * gitlab properties instance on the class.
     *
     * @return The git instance referencing the cloned repository.
     */
    @VisibleForTesting
    Git cloneRepository() {
        final String repositoryURI = generateRepositoryURI(repository);

        log.debug("repositoryURI is {}", repositoryURI);

        final Git git;
        try {
            git = cloneCommand()
                .setURI(repositoryURI)
                .setDirectory(new File(generateLocalRepoPath()))
                .setCredentialsProvider(credentialsProvider)
                .call();

        } catch (GitAPIException e) {
            throw new SystemException("Error cloning repository " + repository, e);
        }
        return git;
    }

    /**
     * Delete the given branch from the remote repository.
     *
     * @param branchToDelete The branch to delete.
     */
    @VisibleForTesting
    void deleteRemoteBranch(String branchToDelete) {
        try {
            final RefSpec refSpec = newRefSpec().setSource(null).setDestination("refs/heads/" + branchToDelete);
            git.push().setCredentialsProvider(credentialsProvider).setRefSpecs(refSpec).setRemote("origin").call();
        } catch (GitAPIException e) {
            throw new SystemException("Error deleting the scratchpad branch " + branchToDelete, e);
        }
    }

    /**
     * Delete the given branch from the local repository.
     *
     * @param branchToDelete The branch to delete.
     */
    @VisibleForTesting
    void deleteLocalBranch(String branchToDelete) {
        try {
            git.branchDelete().setBranchNames(branchToDelete).setForce(true).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error deleting the scratchpad branch " + branchToDelete, e);
        }
    }

    /**
     * Sets the user's info on the git client.  The properties set are the common
     * git configuration properties email and user's name.
     */
    @VisibleForTesting
    void setUserInfo() {
        log.debug("setting user info on the client");
        // TODO What about multiple threads, is this thread safe
        final StoredConfig config = git.getRepository().getConfig();
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, userInfo.getUsername());
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, userInfo.getFullname());
    }

    /**
     * Pull changes from the given remote branch into the current locally checked out branch.  One might
     * pull a remote feature branch into the local master branch in which case the currently checked out local
     * branch is master.
     *
     * @param remoteBranchToPull The remote branch to pull changes from.
     */
    @VisibleForTesting
    void pullRemoteBranchIntoCurrentLocal(String remoteBranchToPull) {
        try {
            git.merge().setSquash(true).setCommit(true).setMessage("I commit therefore I am");
            git.pull().setCredentialsProvider(credentialsProvider).setRemoteBranchName(remoteBranchToPull).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error merging scratch pad into master", e);
        }
    }

    /**
     * Merge the <code>sourceBranch</code> into the currently checked out local branch.
     *
     * @param sourceBranch The branch to merge the changes from.
     */
    void mergeAndCommit(Ref sourceBranch) {
        try {
            git.merge().setSquash(true).setCommit(true).include(sourceBranch).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error merging scratch pad into master", e);
        }
    }

    /**
     * Checkout the given branch.  It is first checked out assuming it exists locally.  If the branch does not
     * exist locally then it is checked out from the remote repository.
     *
     * @param branchName The branch to checkout.
     */
    @VisibleForTesting
    Ref checkoutBranch(String branchName) {
        try {
            return git.checkout().setName(branchName).call();
        } catch (RefNotFoundException e) {
            return checkoutRemoteBranch(branchName);
        } catch (GitAPIException e) {
            throw new SystemException("Error checking out branch " + branchName, e);
        }
    }

    /**
     * Checks out a branch from the remote repository.  Typically this is called when it is known the branch
     * does not already exist locally.
     *
     * @param branchName The branch to check out.
     * @return The {@link Ref} of the branch being checked out.
     */
    @VisibleForTesting
    Ref checkoutRemoteBranch(String branchName) {
        try {
            return git.checkout().setName(branchName).setCreateBranch(true).setUpstreamMode(CreateBranchCommand
                .SetupUpstreamMode.TRACK).setStartPoint(ORIGIN + "/" + branchName).call();
        } catch (GitAPIException e) {
            throw new SystemException("Error checking out branch " + branchName, e);
        }
    }

    /**
     * Generates the name of the scratch pad using the user's username.
     *
     * @return The name of the scratch pad branch.
     */
    @VisibleForTesting
    String generateScratchPadName() {
        return String.format("%s_%s", SCRATCH_PAD, userInfo.getUsername());
    }

    /**
     * The expected URI format to a given repository
     * <fieldName>http://{host}:{port}/{groupName}/{repository}.git</fieldName>
     * <p>
     * A common use for this value is cloning a remote repository.
     *
     * @param repository
     * @return The URI to the remote git repository.
     */
    @VisibleForTesting
    String generateRepositoryURI(String repository) {
        return String.format("%s/%s/%s.git",
            itemBankProperties.getHost(), itemBankProperties.getGroup(), repository);
    }

    /**
     * Generates the path to the item's local repository.
     *
     * @return The path to the item's local repository.
     */
    @VisibleForTesting
    String generateLocalRepoPath() {
        return String.format("%s/%s/%s", itemBankProperties.getLocalBaseDir(), parsedUsername, repository);
    }

    /**
     * Generates the path to the item file on the file system.
     *
     * @param fileName The file to generate the path for.
     * @return The path to the item file.
     */
    @VisibleForTesting
    String generateLocalFilePath(String fileName) {
        return String.format("%s/%s/%s/%s", itemBankProperties.getLocalBaseDir(), parsedUsername, repository,
            fileName);
    }

    /**
     * Generates the item's file name.  The item file is the file holding the SAAIF XML representing the item.
     *
     * @return The name of the item's file.
     */
    @VisibleForTesting
    String generateItemFileName() {
        return String.format("item-%s.xml", repository);
    }

    /**
     * Deletes the given path and all the contents within it.  If the path is not
     * a directory or the path does not exist then nothing happens.  There is no error
     * thrown and no files are deleted.
     *
     * @param directoryToDelete The directory to delete.
     */
    @VisibleForTesting
    void deleteDirectory(Path directoryToDelete) {
        if (Files.exists(directoryToDelete) && Files.isDirectory(directoryToDelete)) {
            try {
                Files.walk(directoryToDelete, FileVisitOption.FOLLOW_LINKS)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
//                    .peek(out::println)
                    .forEach(File::delete);
            } catch (Exception e) {
                throw new SystemException("Error trying to delete a directory", e);
            }
        }
    }

    /**
     * Creates a new instance of {@link CloneCommand}.
     *
     * @return A new instance of {@link CloneCommand}.
     */
    @VisibleForTesting
    CloneCommand cloneCommand() {
        return Git.cloneRepository();
    }

    /**
     * Creates a new instance of {@link RefSpec}.
     *
     * @return a new instance of {@link RefSpec}.
     */
    @VisibleForTesting
    RefSpec newRefSpec() {
        return new RefSpec();
    }

    /**
     * Set the {@link Git} instance.
     *
     * @param git The {@link Git} instance to set.
     */
    @VisibleForTesting
    void setGit(Git git) {
        this.git = git;
    }
}
