/*
 *  Copyright 2017 Regents of the University of California.
 *
 *  Licensed under the Educational Community License, Version 2.0 (the "license");
 *  you may not use this file except in compliance with the License. You may
 *  obtain a copy of the license at
 *
 *  https://opensource.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestsystem.ap.ims.client;

import com.google.common.annotations.VisibleForTesting;
import lombok.extern.slf4j.Slf4j;
import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PushCommand;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.ap.ims.config.GitlabProperties;
import org.opentestsystem.ap.ims.util.SecurityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Optional;

/**
 * A GIT client using JGit.  The client is built around a GitLab group.
 * An instance of this repository operates within a group.  Cloned repositories
 * are expected to exist under the group in GitLab.
 */
@Slf4j
@Repository
public class GitLabGitClientImpl implements GitClient {

    public static final String SCRATCH_PAD = "scratch-pad";

    public static final String README_FILE = "README.md";

    public static final String GIT_CONFIG_USER = "user";
    public static final String GIT_CONFIG_USER_NAME = "name";
    public static final String GIT_CONFIG_USER_EMAIL = "email";

    private final GitlabProperties gitlabProperties;

    private final SecurityUtil securityUtil;

    @Autowired
    public GitLabGitClientImpl(GitlabProperties gitlabProperties, SecurityUtil securityUtil) {
        this.gitlabProperties = gitlabProperties;
        this.securityUtil = securityUtil;
    }

    /**
     * @inheritDoc
     */
    @Override
    public void initializeRemoteRepository(String repository) {
        final SecurityUtil.UserInfo userInfo = securityUtil.getUserInfo();
        final Git git = cloneRepository(repository);
        setUserInfo(git);
        writeReadMeToLocalRepo(repository);
        addReadMe(git);
        commit(git, gitlabProperties.getOptionalInitialCommitMessage());
        push(git);
        //
        initializeScratchPad(git, userInfo);
        writeItemFileToLocalRepo(repository);
        addItemFile(git, repository);
        commit(git, Optional.of("creating new item file"));
        push(git);
    }

    /**
     * @inheritDoc
     */
    @Override
    public void cloneRemoteRepository(String repository) {
        cloneRepository(repository);
    }

    // ------------------------------------------------------------------------

    void initializeScratchPad(Git git, SecurityUtil.UserInfo userInfo) {
        try {
            git.branchCreate().setName(SCRATCH_PAD).call();
            git.checkout().setName(SCRATCH_PAD).call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Problem creating scratch pad branch", e);
        }
    }

    boolean doesScratchPadBranchExist(Git git) {
        boolean exists = true;
        Collection<Ref> heads = Collections.emptyList();
        try {
            heads = git.lsRemote().setHeads(true).call();
            if (heads != null && !heads.isEmpty()) {
                for (Ref head : heads) {
                    System.out.println(head.getName());
                }
            }
        } catch (GitAPIException e) {
            throw new RuntimeException("Problem calling ls-remote on repository", e);
        }

        return exists;
    }

    @VisibleForTesting
    void setUserInfo(Git git) {
        log.debug("setting user info on the Git session");

        final SecurityUtil.UserInfo userInfo = securityUtil.getUserInfo();

        // TODO What about multiple threads, is this thread safe
        final StoredConfig config = git.getRepository().getConfig();
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_EMAIL, userInfo.getUsername());
        config.setString(GIT_CONFIG_USER, null, GIT_CONFIG_USER_NAME, userInfo.getFullname());
    }


    /**
     * Clones the given repository where the repository URI is built with an expected format
     * matching an existing remote repository.  The remote repository is cloned locally at
     * a pre-configured location.  Credentials are required and should be provided by the
     * gitlab properties instance on the class.
     *
     * @param repository The name of the repository to clone.
     * @return The git instance referencing the cloned repository.
     */
    @VisibleForTesting
    Git cloneRepository(String repository) {
        final String repositoryURI = generateRepositoryURI(repository);

        log.debug("repositoryURI is {}", repositoryURI);

        final Git git;
        try {
            git = cloneCommand()
                .setURI(repositoryURI)
                .setDirectory(new File(gitlabProperties.getLocalBaseDir() + "/" + repository))
                .setCredentialsProvider(
                    new UsernamePasswordCredentialsProvider(
                        gitlabProperties.getUser(),
                        gitlabProperties.getPassword()))
                .call();

        } catch (GitAPIException e) {
            throw new RuntimeException("Error cloning repository " + repository, e);
        }
        return git;
    }

    /**
     * Pushes local pending commits to the remote repository.
     *
     * @param git The git instance poniting to the repository of interest.
     */
    @VisibleForTesting
    void push(Git git) {
        final PushCommand push = git.push();
        try {
            push.setCredentialsProvider(
                new UsernamePasswordCredentialsProvider(gitlabProperties.getUser(), gitlabProperties.getPassword()))
                .call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Error pushing changes", e);
        }
    }

    /**
     * Commits what has been staged in the local repository.
     *
     * @param git     The git instance pointing to the repository of interest.
     * @param message The optional commit message.
     */
    @VisibleForTesting
    void commit(Git git, Optional<String> message) {
        final CommitCommand commit = git.commit();
        try {
            message.ifPresent(commitMessage -> commit.setMessage(commitMessage));
            commit.call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Error during initial commit", e);
        }
    }

    /**
     * Expects a README.md file to exist in the given git instance.  The git
     * instances represents a local get repository.
     *
     * @param git The local get repository the README.md is being added to.
     */
    @VisibleForTesting
    void addReadMe(Git git) {
        addFiles(git, README_FILE);
    }

    @VisibleForTesting
    void addItemFile(Git git, String repository) {
        addFiles(git, "item-" + repository + ".xml");
    }

    void addFiles(Git git, String filePattern) {
        final AddCommand add = git.add();
        try {
            add.addFilepattern(filePattern).call();
        } catch (GitAPIException e) {
            throw new RuntimeException("Error adding README file", e);
        }
    }

    /**
     * Writes a README.md file to the local repository.  The README file is empty.
     *
     * @param repository The name of the local repository to write to.
     */
    @VisibleForTesting
    void writeReadMeToLocalRepo(String repository) {
        final String readmeFilePath = String.format("%s/%s/%s", gitlabProperties.getLocalBaseDir(), repository,
            README_FILE);

        log.debug("generate readme {}", readmeFilePath);

        try {
            Files.createFile(Paths.get(readmeFilePath));
        } catch (IOException e) {
            throw new RuntimeException("Error generating readme for repository " + repository, e);
        }
    }

    @VisibleForTesting
    void writeItemFileToLocalRepo(String repository) {
        final String itemFilePath = String.format("%s/%s/%s", gitlabProperties.getLocalBaseDir(), repository,
            "item-" + repository + ".xml");

        log.debug("generate item file {}", itemFilePath);

        try {
            Files.createFile(Paths.get(itemFilePath));
        } catch (IOException e) {
            throw new RuntimeException("Error generating readme for repository " + repository, e);
        }
    }


    /**
     * The expected URI format to a given repository
     * <code>http://{host}:{port}/{groupName}/{repository}.git</code>
     * <p>
     * A common use for this value is cloning a remote repository.
     *
     * @param repository
     * @return The URI to the remote git repository.
     */
    @VisibleForTesting
    String generateRepositoryURI(String repository) {
        return String.format("%s/%s/%s.git",
            gitlabProperties.getHost(), gitlabProperties.getGroup(), repository);
    }

    /**
     * Deletes the given path and all the contents within it.  If the path is not
     * a directory or the path does not exist then nothing happens.  There is no error
     * thrown and not files are deleted.
     *
     * @param directoryToDelete The directory to delete.
     */
    @VisibleForTesting
    void deleteDirectory(Path directoryToDelete) {
        if (Files.exists(directoryToDelete) && Files.isDirectory(directoryToDelete)) {
            try {
                Files.walk(directoryToDelete, FileVisitOption.FOLLOW_LINKS)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .peek(System.out::println)
                    .forEach(File::delete);
            } catch (Exception e) {
                throw new RuntimeException("Error trying to delete a directory", e);
            }
        }
    }

    @VisibleForTesting
    CloneCommand cloneCommand() {
        return Git.cloneRepository();
    }

}
